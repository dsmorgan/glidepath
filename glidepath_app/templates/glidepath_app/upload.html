{% extends 'glidepath_app/base.html' %}
{% block title %}Glidepath - Rules{% endblock %}
{% block content %}
<div class="bg-white shadow rounded-lg p-6">
    <h1 class="text-3xl font-bold text-gray-900 mb-6">Glidepath Rules</h1>

    {% if error %}
    <div class="bg-red-50 border-l-4 border-red-400 p-4 mb-4">
        <p class="text-red-700">{{ error }}</p>
    </div>
    {% endif %}

    <div class="mb-6 p-4 bg-gray-50 rounded-lg">
        <div class="flex flex-wrap items-center gap-4">
            <!-- Ruleset Selector -->
            <div class="flex-1 min-w-[200px]">
                <label class="block text-sm font-medium text-gray-700 mb-1">Select Ruleset</label>
                <select id="rulesetSelect" name="ruleset" class="w-full border border-gray-300 rounded-md p-2" onchange="updateActions(); htmx.ajax('GET', '{% url 'rules' %}?ruleset=' + this.value, '#rules');">
                    <option value="">-- Select a Ruleset --</option>
                    {% for rs in rule_sets %}
                        <option value="{{ rs.id }}" {% if selected_set and rs.id == selected_set.id %}selected{% endif %}>{{ rs.name }}</option>
                    {% endfor %}
                </select>
            </div>

            <!-- Actions -->
            <div class="flex gap-2 items-end">
                <!-- Export Button -->
                <a id="exportBtn" href="#"
                   class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 inline-flex items-center whitespace-nowrap pointer-events-none opacity-50"
                   onclick="if (this.getAttribute('data-id')) { location.href = '{% url 'export_rules' %}?ruleset=' + this.getAttribute('data-id'); return false; }">
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                    </svg>
                    Export CSV
                </a>

                <!-- Rename Button -->
                <button id="renameBtn" type="button"
                        class="px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap pointer-events-none opacity-50"
                        disabled onclick="renameRuleset(document.getElementById('rulesetSelect').value)">
                    Rename Ruleset
                </button>

                <!-- Delete Button -->
                <button id="deleteBtn" type="button"
                        class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap pointer-events-none opacity-50"
                        disabled onclick="deleteRulesetHandler()">
                    Delete Ruleset
                </button>

                <!-- Upload Button -->
                <form method="post" enctype="multipart/form-data" class="inline-block">
                    {% csrf_token %}
                    <div class="flex gap-2">
                        <input type="file" name="file" required class="border border-gray-300 rounded-md p-2 text-sm">
                        <button type="submit" class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 whitespace-nowrap">
                            Upload CSV
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div id="rules">
        {% include 'glidepath_app/rules.html' %}
    </div>
</div>

<script>
function getYearOfRetirement() {
    const yearBorn = parseInt(document.getElementById('yearBornSelect')?.value || 1973);
    const retirementAge = parseInt(document.getElementById('retirementAgeSelect')?.value || 58);
    return yearBorn + retirementAge;
}

function transformChartLabelsForDisplay(chartData) {
    if (!chartData || !chartData.labels) {
        return chartData;
    }

    const yearOfRetirement = getYearOfRetirement();
    const ageToYearMap = {
        'earlier': 'Earlier',
        'later': 'Later'
    };

    const transformedLabels = chartData.labels.map(label => {
        if (ageToYearMap[label]) {
            return ageToYearMap[label];
        }
        // Convert age offset to year
        const ageOffset = parseInt(label);
        if (!isNaN(ageOffset)) {
            return yearOfRetirement + ageOffset;
        }
        return label;
    });

    return {
        ...chartData,
        labels: transformedLabels,
        originalLabels: chartData.labels  // Store original labels for reference
    };
}

function findRetirementLineIndex(transformedChartData) {
    // Find the index where the original label was "0" (the retirement year)
    if (!transformedChartData || !transformedChartData.originalLabels) {
        return -1;
    }

    const index = transformedChartData.originalLabels.indexOf('0');
    return index !== -1 ? index : -1;
}

function findCurrentYearIndex(transformedLabels) {
    // Find the index where current year appears in the transformed labels
    if (!transformedLabels) {
        return -1;
    }

    const currentYear = new Date().getFullYear();

    // Look for exact match first
    const exactIndex = transformedLabels.indexOf(currentYear.toString());
    if (exactIndex !== -1) {
        return exactIndex;
    }

    // Get indices and values for comparison
    let earlierIndex = -1;
    let laterIndex = -1;
    const yearData = []; // Array of {index, value}

    for (let i = 0; i < transformedLabels.length; i++) {
        const label = transformedLabels[i];
        if (label === 'Earlier') {
            earlierIndex = i;
        } else if (label === 'Later') {
            laterIndex = i;
        } else {
            const yearValue = parseInt(label);
            if (!isNaN(yearValue)) {
                yearData.push({ index: i, value: yearValue });
            }
        }
    }

    // If no year data exists, return -1
    if (yearData.length === 0) {
        return -1;
    }

    // Sort by year value
    yearData.sort((a, b) => a.value - b.value);

    // Check if current year is outside the range
    if (currentYear < yearData[0].value) {
        // Current year is before all years - use "Earlier"
        return earlierIndex !== -1 ? earlierIndex : yearData[0].index;
    } else if (currentYear > yearData[yearData.length - 1].value) {
        // Current year is after all years - use "Later"
        return laterIndex !== -1 ? laterIndex : yearData[yearData.length - 1].index;
    }

    // Current year is within range - find closest match
    let closestIndex = yearData[0].index;
    let closestDiff = Math.abs(yearData[0].value - currentYear);

    for (let i = 1; i < yearData.length; i++) {
        const diff = Math.abs(yearData[i].value - currentYear);
        if (diff < closestDiff) {
            closestDiff = diff;
            closestIndex = yearData[i].index;
        }
    }

    return closestIndex;
}

function findPieChartIndex() {
    if (!window.chartDataStaged || !window.chartDataStaged.classChart) {
        return -1;
    }

    const yearOfRetirement = getYearOfRetirement();
    const currentYear = new Date().getFullYear();
    const currentAgeOffset = currentYear - yearOfRetirement;

    const labels = window.chartDataStaged.classChart.labels;

    // Find the appropriate age offset
    let bestIndex = -1;
    let bestAgeOffset = null;

    labels.forEach((label, idx) => {
        if (label === 'earlier') return;
        if (label === 'later') {
            // Use 'later' as fallback if current year is beyond all defined ages
            if (bestIndex === -1) {
                bestIndex = idx;
                bestAgeOffset = Infinity;
            }
            return;
        }

        const ageOffset = parseInt(label);
        if (!isNaN(ageOffset)) {
            // Find the highest age offset that is <= currentAgeOffset
            if (ageOffset <= currentAgeOffset) {
                if (bestAgeOffset === null || ageOffset > bestAgeOffset) {
                    bestIndex = idx;
                    bestAgeOffset = ageOffset;
                }
            }
        }
    });

    return bestIndex;
}

function updateTableYearAndAge() {
    // Calculate Year and Age for all table rows
    const yearBorn = parseInt(document.getElementById('yearBornSelect')?.value || 1973);
    const retirementAge = parseInt(document.getElementById('retirementAgeSelect')?.value || 58);
    const yearOfRetirement = yearBorn + retirementAge;

    // Get all table rows with age data
    const rows = document.querySelectorAll('table tbody tr[data-gt-retire-age]');

    rows.forEach(row => {
        const gtRetireAge = parseInt(row.getAttribute('data-gt-retire-age'));
        const ltRetireAge = parseInt(row.getAttribute('data-lt-retire-age'));

        // Find Year and Age cells
        const yearCell = row.querySelector('.year-cell');
        const ageCell = row.querySelector('.age-cell');

        let yearValue, ageValue;

        // Check for special cases
        if (gtRetireAge === -100) {
            yearValue = 'Earlier';
            ageValue = 'Younger';
        } else if (ltRetireAge === 100) {
            yearValue = 'Later';
            ageValue = 'Older';
        } else {
            // Calculate normal values
            yearValue = yearOfRetirement + gtRetireAge;
            ageValue = retirementAge + gtRetireAge;
        }

        // Update cells
        if (yearCell) yearCell.textContent = yearValue;
        if (ageCell) ageCell.textContent = ageValue;
    });
}

function updatePieChartSelection() {
    // Save to sessionStorage
    sessionStorage.setItem('yearBorn', document.getElementById('yearBornSelect').value);
    sessionStorage.setItem('retirementAge', document.getElementById('retirementAgeSelect').value);

    // Update charts and table
    updateCharts();
    updateTableYearAndAge();
}

function initializeCharts() {
    // Destroy existing charts
    if (window.classChart) {
        chartAdapter.destroy(window.classChart);
        window.classChart = null;
    }
    if (window.categoryChart) {
        chartAdapter.destroy(window.categoryChart);
        window.categoryChart = null;
    }
    if (window.classPieChart) {
        chartAdapter.destroy(window.classPieChart);
        window.classPieChart = null;
    }

    // Load or initialize dropdown values from sessionStorage
    const yearBornSelect = document.getElementById('yearBornSelect');
    const retirementAgeSelect = document.getElementById('retirementAgeSelect');

    if (yearBornSelect && retirementAgeSelect) {
        const savedYearBorn = sessionStorage.getItem('yearBorn') || '1973';
        const savedRetirementAge = sessionStorage.getItem('retirementAge') || '58';

        yearBornSelect.value = savedYearBorn;
        retirementAgeSelect.value = savedRetirementAge;
    }

    updateCharts();
}

function updateCharts() {
    const classCanvas = document.getElementById('classChart');
    const categoryCanvas = document.getElementById('categoryChart');
    const pieCanvas = document.getElementById('classPieChart');

    if (!classCanvas || !categoryCanvas || !pieCanvas) {
        return;
    }

    const tooltip = {
        callbacks: {
            label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y}%`
        }
    };

    const commonOpts = {
        plugins: { legend: { position: 'bottom' }, tooltip },
        scales: { x: { stacked: true }, y: { stacked: true, ticks: { callback: v => v + '%' } } },
        responsive: true,
        maintainAspectRatio: false,
        animation: {
            duration: 750  // Smooth animation
        }
    };

    // Get the chart data from window variable set by the template
    if (window.chartDataStaged) {
        let { classChart: classChartData, categoryChart: categoryChartData } = window.chartDataStaged;

        // Transform labels for area charts (age offset to year display)
        classChartData = transformChartLabelsForDisplay(classChartData);
        categoryChartData = transformChartLabelsForDisplay(categoryChartData);

        // Find the retirement line and current year line indices
        const retirementLineIndex = findRetirementLineIndex(classChartData);
        const currentYearIndex = findCurrentYearIndex(classChartData.labels);

        // Create plugin to draw both retirement and current year lines
        const retirePlugin = {
            id: 'retireLine',
            afterDraw(chart) {
                const ctx = chart.ctx;

                // Draw retirement line FIRST (red solid with label)
                if (retirementLineIndex !== -1) {
                    const x = chart.scales.x.getPixelForValue(retirementLineIndex);

                    // Draw line
                    ctx.save();
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]); // Ensure solid
                    ctx.beginPath();
                    ctx.moveTo(x, chart.chartArea.top);
                    ctx.lineTo(x, chart.chartArea.bottom);
                    ctx.stroke();
                    ctx.restore();

                    // Draw label INSIDE the top of the chart area where it's guaranteed to be visible
                    ctx.save();
                    ctx.fillStyle = 'red';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    // Draw at the top inside the chart area with small padding
                    ctx.fillText('Retirement', x, chart.chartArea.top + 5);
                    ctx.restore();
                }

                // Draw current year line SECOND (black dashed, no label) - appears ON TOP
                if (currentYearIndex !== -1) {
                    ctx.save();
                    const x = chart.scales.x.getPixelForValue(currentYearIndex);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]); // Dashed pattern
                    ctx.beginPath();
                    ctx.moveTo(x, chart.chartArea.top);
                    ctx.lineTo(x, chart.chartArea.bottom);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        };

        // Destroy and recreate charts with smooth animation
        if (window.classChart) {
            chartAdapter.destroy(window.classChart);
        }
        window.classChart = chartAdapter.init(
            classCanvas.getContext('2d'),
            { type: 'line', data: classChartData, options: commonOpts, plugins:[retirePlugin] }
        );

        if (window.categoryChart) {
            chartAdapter.destroy(window.categoryChart);
        }
        window.categoryChart = chartAdapter.init(
            categoryCanvas.getContext('2d'),
            { type: 'line', data: categoryChartData, options: commonOpts, plugins:[retirePlugin] }
        );

        // Build dynamic pie chart data based on current year
        const pieIndex = findPieChartIndex();
        let dynamicPieData = { labels: [], datasets: [{ data: [], backgroundColor: [] }] };

        if (pieIndex !== -1 && window.chartDataStaged.classChart.datasets.length > 0) {
            dynamicPieData.labels = window.chartDataStaged.classChart.datasets.map(ds => ds.label);
            dynamicPieData.datasets[0].data = window.chartDataStaged.classChart.datasets.map(ds => ds.data[pieIndex]);
            dynamicPieData.datasets[0].backgroundColor = window.chartDataStaged.classChart.datasets.map(ds => ds.backgroundColor);
        }

        const pieOpts = {
            plugins: {
                legend: { position: 'bottom' },
                tooltip: {
                    callbacks: {
                        label: ctx => `${ctx.label}: ${ctx.parsed}%`
                    }
                }
            },
            responsive: true,
            maintainAspectRatio: false,
            animation: {
                duration: 750  // Smooth animation
            }
        };

        if (window.classPieChart) {
            chartAdapter.destroy(window.classPieChart);
        }
        window.classPieChart = chartAdapter.init(
            pieCanvas.getContext('2d'),
            { type: 'pie', data: dynamicPieData, options: pieOpts }
        );
    }
}

// Initialize charts and table on first page load
document.addEventListener('DOMContentLoaded', function() {
    initializeCharts();
    updateActions();
    updateTableYearAndAge();
});

// Re-initialize charts and table when HTMX swaps the rules content
document.getElementById('rules').addEventListener('htmx:afterSwap', function() {
    setTimeout(initializeCharts, 50);
    setTimeout(updateTableYearAndAge, 50);
});

// Update button states based on selected ruleset
function updateActions() {
    const select = document.getElementById('rulesetSelect');
    const exportBtn = document.getElementById('exportBtn');
    const renameBtn = document.getElementById('renameBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const selectedId = select.value;

    if (selectedId) {
        exportBtn.setAttribute('data-id', selectedId);
        exportBtn.classList.remove('pointer-events-none', 'opacity-50');
        exportBtn.classList.add('hover:bg-blue-600', 'cursor-pointer');

        renameBtn.disabled = false;
        renameBtn.classList.remove('pointer-events-none', 'opacity-50');
        renameBtn.classList.add('hover:bg-purple-600', 'cursor-pointer');

        deleteBtn.disabled = false;
        deleteBtn.classList.remove('pointer-events-none', 'opacity-50');
        deleteBtn.classList.add('hover:bg-red-600', 'cursor-pointer');
    } else {
        exportBtn.removeAttribute('data-id');
        exportBtn.classList.add('pointer-events-none', 'opacity-50');
        exportBtn.classList.remove('hover:bg-blue-600', 'cursor-pointer');

        renameBtn.disabled = true;
        renameBtn.classList.add('pointer-events-none', 'opacity-50');
        renameBtn.classList.remove('hover:bg-purple-600', 'cursor-pointer');

        deleteBtn.disabled = true;
        deleteBtn.classList.add('pointer-events-none', 'opacity-50');
        deleteBtn.classList.remove('hover:bg-red-600', 'cursor-pointer');
    }
}

// Delete ruleset handler with confirmation
function deleteRulesetHandler() {
    const select = document.getElementById('rulesetSelect');
    const rulesetId = select.value;

    if (!rulesetId) {
        alert('Please select a ruleset to delete.');
        return;
    }

    const rulesetName = select.options[select.selectedIndex].text;
    const confirmed = confirm(`Are you sure you want to delete the ruleset "${rulesetName}"? This action cannot be undone.`);

    if (confirmed) {
        const form = document.createElement('form');
        form.method = 'POST';
        form.innerHTML = `
            <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">
            <input type="hidden" name="delete" value="${rulesetId}">
        `;
        document.body.appendChild(form);
        form.submit();
    }
}

// Rename ruleset
function renameRuleset(rulesetId) {
    if (!rulesetId) {
        alert('Please select a ruleset to rename.');
        return;
    }

    const select = document.getElementById('rulesetSelect');
    const currentName = select.options[select.selectedIndex].text;
    const newName = prompt(`Enter new name for ruleset:`, currentName);

    if (newName && newName !== currentName) {
        const form = document.createElement('form');
        form.method = 'POST';
        form.innerHTML = `
            <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">
            <input type="hidden" name="rename" value="${rulesetId}">
            <input type="hidden" name="new_name" value="${newName.replace(/"/g, '&quot;')}">
        `;
        document.body.appendChild(form);
        form.submit();
    }
}
</script>
{% endblock %}
